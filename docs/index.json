{
  "about/index.html": {
    "href": "about/index.html",
    "title": "",
    "keywords": "该文档由fjqisba个人编写。"
  },
  "HEXRAYSDK/CFunc.html": {
    "href": "HEXRAYSDK/CFunc.html",
    "title": "CFunc",
    "keywords": "CFunc CFunc与反编译的函数有关。cfunc_t结构体用于存储反编译的结果。 get_line_item 函数原型如下: bool get_line_item(const char *line, int x, bool is_ctree_line, ctree_item_t *phead, ctree_item_t *pitem, ctree_item_t *ptail); 该函数用于获取指定位置的ctree item。 参数一line为反编译文本中的某一行。 参数二x为反编译文本行中的横坐标。 参数三is_ctree_line表示是否在声明语句区域(如果不是，则假定为变量声明语句区域)。 参数四phead为返回的item的头部，用于附加块注释。可为空。 参数五pitem为返回的item。可为空。 参数六ptail为返回的item的尾部，用于附加缩进的注释。可为空。 如果没有获取到pitem，则函数返回值为false。 我们可以使用该函数给代码添加注释，示例代码如下: #include <hexrays.hpp> bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, &hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } const strvec_t& sv = cfunc->sv; //给函数的每行代码添加注释 for (unsigned int n = 1; n < sv.size(); ++n) { ctree_item_t commentItem; cfunc->get_line_item(sv[n].line.c_str(), 0, true, NULL, NULL, &commentItem); qstring qComment; qComment.sprnt(\"%d\", n); cfunc->set_user_cmt(commentItem.loc, qComment.c_str()); } //添加注释后务必调用此函数保存注释 cfunc->save_user_cmts(); return true; }"
  },
  "HEXRAYSDK/CTree.html": {
    "href": "HEXRAYSDK/CTree.html",
    "title": "CTree",
    "keywords": "CTree 在理解CTree的核心之前，我们还需要认识以下类: cfunc_t :cfunc_t中包含着和反编译代码相关的一些基础信息，cfunc_t中存在一个body成员，是一个cinsn_t类型，代表整个反编译函数的主体。 struct cfunc_t { ea_t entry_ea; ///< function entry address cinsn_t body; ///< 函数的主体, 一定是个cblock类型 //... } cinsn_t :cinsn_t代表着用来组成CTree的每条语句，结构体内的节点主要和流程控制有关。 struct cinsn_t : public citem_t { union { cblock_t *cblock; ///< details of block-statement cexpr_t *cexpr; ///< details of expression-statement cif_t *cif; ///< details of if-statement cfor_t *cfor; ///< details of for-statement cwhile_t *cwhile; ///< details of while-statement cdo_t *cdo; ///< details of do-statement cswitch_t *cswitch; ///< details of switch-statement creturn_t *creturn; ///< details of return-statement cgoto_t *cgoto; ///< details of goto-statement casm_t *casm; ///< details of asm-statement }; } cexpr_t :cexpr_t代表着用来组成每条语句的C语言表达式，可能也是最常用的一个类，里面存储着每条表达式的关键信息。 struct cexpr_t : public citem_t { union { cnumber_t *n; ///< used for \\ref cot_num fnumber_t *fpc; ///< used for \\ref cot_fnum struct { union { var_ref_t v; ///< used for \\ref cot_var ea_t obj_ea; ///< used for \\ref cot_obj }; int refwidth; ///< how many bytes are accessed? (-1: none) }; struct { cexpr_t *x; ///< the first operand of the expression union { cexpr_t *y; ///< the second operand of the expression carglist_t *a;///< argument list (used for \\ref cot_call) uint32 m; ///< member offset (used for \\ref cot_memptr, \\ref cot_memref) ///< for unions, the member number }; union { cexpr_t *z; ///< the third operand of the expression int ptrsize; ///< memory access size (used for \\ref cot_ptr, \\ref cot_memptr) }; }; cinsn_t *insn; ///< an embedded statement, they are prohibited ///< at the final maturity stage (\\ref CMAT_FINAL) char *helper; ///< helper name (used for \\ref cot_helper) char *string; ///< string constant (used for \\ref cot_str) }; tinfo_t type; ///< expression type. must be carefully maintained } citem_t :citem_t是cinsn_t和cexpr_t的基类，用来存储一些通用的信息，例如地址、标签。 为了更进一步地了解CTree，以下代码展示了如何去遍历函数的CTree节点，并且实现了一个C语句表达式的模板化引擎。 #include <hexrays.hpp> qstring GetExprString(cexpr_t* pItem) { qstring ret; switch (pItem->op) { case cot_add: return GetExprString(pItem->x) + \"+\" + GetExprString(pItem->y); case cot_asg: return GetExprString(pItem->x) + \"=\" + GetExprString(pItem->y); case cot_asgadd: return GetExprString(pItem->x) + \"+=\" + GetExprString(pItem->y); case cot_band: return GetExprString(pItem->x) + \"&\" + GetExprString(pItem->y); case cot_call: ret = \"call(\"; for (unsigned int n = 0; n < pItem->a->size(); ++n) { ret += GetExprString(&pItem->a->at(n)) + \",\"; } if (pItem->a->size()) { ret.remove_last(); } ret += \")\"; return ret; case cot_cast: return qstring(\"(cast)\") + GetExprString(pItem->x); case cot_eq: return GetExprString(pItem->x) + \"==\" + GetExprString(pItem->y); case cot_idx: return GetExprString(pItem->x) + qstring(\"[\") + GetExprString(pItem->y) + qstring(\"]\"); case cot_mul: return GetExprString(pItem->x) + \"*\" + GetExprString(pItem->y); case cot_num: ret = \"num\"; break; case cot_obj: ret = \"obj\"; break; case cot_ref: return qstring(\"&\") + GetExprString(pItem->x); case cot_var: ret = \"var\"; break; case cot_preinc: return qstring(\"++\") + GetExprString(pItem->x); break; case cot_ptr: return qstring(\"*\") + GetExprString(pItem->x); break; case cot_sub: return GetExprString(pItem->x) + \"-\" + GetExprString(pItem->y); case cot_tern: return GetExprString(pItem->x) + \"?\" + GetExprString(pItem->y) + \":\" + GetExprString(pItem->z); case cot_ult: return GetExprString(pItem->x) + \"<\" + GetExprString(pItem->y); case cot_xor: return GetExprString(pItem->x) + \"^\" + GetExprString(pItem->y); default: //遇到没解析过的类型自行补充就行了 msg(\"UnHandled Item Type...\\n\"); break; } return ret; } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t* pfn = get_func(get_screen_ea()); hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, &hf, DECOMP_WARNINGS); if (cfunc == NULL) { warning(\"error\"); return true; } ctree_items_t& vec_TreeItem = cfunc->treeitems; for (unsigned int n = 0; n < vec_TreeItem.size(); ++n) { //打印出所有的表达式吧 if (vec_TreeItem[n]->op == cit_expr) { qstring ExprPatterm = GetExprString(((cexpr_t*)vec_TreeItem[n])->x); msg(\"%s\\n\", ExprPatterm.c_str()); } } return true; }"
  },
  "HEXRAYSDK/HexRaysSDK.html": {
    "href": "HEXRAYSDK/HexRaysSDK.html",
    "title": "HexRays SDK简介",
    "keywords": "HexRays SDK简介 IDA反编译器Hex-Rays是作为IDA的插件而存在的，它可以将IDA反汇编代码转换成类C语言伪代码。 同时官方还提供了一组HexRays SDK，供用户使用。 SDK使用方法很简单，只需要将hexrays.hpp文件包含即可。 在HexRays反编译器中二进制代码有两种存在的形式，一种是microcode，一种是ctree。 microcode :微码，由一条一条的处理器指令组成，由反编译器来进行优化并转换。 ctree :Ctree由经过优化过后的微码生成，其内部其实是一个用C语句和表达式构建的类抽象语法树。Ctree可以转换为伪C代码。 官方示例代码如下: #include <hexrays.hpp> // Hex-Rays API pointer hexdsp_t *hexdsp = NULL; static bool inited = false; //-------------------------------------------------------------------------- int idaapi init(void) { //初始化hexrays插件 if ( !init_hexrays_plugin() ) { return PLUGIN_SKIP; // no decompiler } inited = true; return PLUGIN_KEEP; } //-------------------------------------------------------------------------- void idaapi term(void) { //释放hexrays插件 if ( inited ) { term_hexrays_plugin(); } } //-------------------------------------------------------------------------- bool idaapi run(size_t) { func_t *pfn = get_func(get_screen_ea()); if ( pfn == NULL ) { warning(\"Please position the cursor within a function\"); return true; } hexrays_failure_t hf; cfuncptr_t cfunc = decompile(pfn, &hf, DECOMP_WARNINGS); if ( cfunc == NULL ) { warning(\"#error \\\"%a: %s\", hf.errea, hf.desc().c_str()); return true; } msg(\"%a: successfully decompiled\\n\", pfn->start_ea); const strvec_t &sv = cfunc->get_pseudocode(); for ( int i=0; i < sv.size(); i++ ) { qstring buf; tag_remove(&buf, sv[i].line); msg(\"%s\\n\", buf.c_str()); } return true; } //-------------------------------------------------------------------------- static char comment[] = \"Sample1 plugin for Hex-Rays decompiler\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // plugin flags init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // long comment about the plugin // it could appear in the status line // or as a hint \"\", // multiline help about the plugin \"Decompile & Print\", // the preferred short name of the plugin \"\" // the preferred hotkey to run the plugin }; 上述代码的作用就是打印出当前窗口所在函数的伪代码文本。 除了执行上面的代码稍微体验一下HexRays的强大之外，我们还需要知道以下几点： 1.cfunc_t可以理解为操作反编译器API功能的入口，很多功能都要依赖这个类来实现 2. decompile 函数几乎是我们主动获取cfunc_t的唯一接口。"
  },
  "IDASDK/(auto.hpp)IDA自动分析器.html": {
    "href": "IDASDK/(auto.hpp)IDA自动分析器.html",
    "title": "IDA自动分析器",
    "keywords": "IDA自动分析器 在auto.hpp中，包含了关于IDA自动分析引擎相关的一些函数。 当加载一个新的二进制文件的时候，IDA的自动分析引擎便会开始工作。 IDA的自动分析器包含多个分析队列，每个队列有各自的优先级。当所有的分析队列都为空的时候IDA就会结束自动分析。 通过头文件中提供的接口，我们可以对自动分析器进行一些控制。此接口一般来说用的比较少。。。。。。 有的时候我们需要对自动分析引擎的状态进行判断，因为自动分析引擎的结果可能会影响到插件的使用。 这个时候可以使用 auto_is_ok ，该函数作用为判断分析队列是否全部为空。 bool auto_is_ok(void); 示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <auto.hpp> bool idaapi run(size_t) { if (!auto_is_ok() && ask_yn(0, \"The autoanalysis has not finished yet.\\nDo you want to continue?\") < 1) { return false; } //To do...执行功能 msg(\"[IDADemo]:Test\\n\"); return true; } 还有一种情况是我们通过其它的API，比如使用add_func在某处汇编代码处生成了函数或者修改了某个导入函数的参数类型，这会使得自动分析队列添加新的分析任务。 这个时候我们想要等待自动分析引擎结束工作后，再执行插件的后续步骤，可以使用如下接口。 该函数的作用是阻塞等待，直到分析队列为空。 bool auto_wait(void); 由于此函数阻塞后会使得IDA处于假死状态，我们可以在调用该函数前加上一个提示窗，示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <auto.hpp> bool idaapi run(size_t) { //添加某个函数使得分析队列不为空 add_func(0x405670); show_wait_box(\"Add some Function\"); auto_wait(); hide_wait_box(); return true; }"
  },
  "IDASDK/(bytes.hpp)反汇编字节相关.html": {
    "href": "IDASDK/(bytes.hpp)反汇编字节相关.html",
    "title": "反汇编字节相关",
    "keywords": "反汇编字节相关 在bytes.hpp中提供的接口代表着IDA对二进制代码反汇编字节分析的一些结果。 最常用的就是数据读写了。例如 get_byte 、 get_word 、 get_dword 等函数，用于获取指定地址的数据。其中 get_bytes 函数用来获取指定大小的连续数据。 patch_byte 、 patch_word 、 patch_dword 等函数，用于修改指定地址的数据。 set_cmt / append_cmt / get_cmt 函数，用于反汇编窗口添加注释或者获取注释内容。 bin_search2 函数，用于二进制搜索，有两种调用方法，两种方法其实本质是一样的，官方推荐的做法可能是第一种文本模板，文本语法与IDA官方的Alt+B功能相似。 ea_t bin_search2(ea_t start_ea,ea_t end_ea,const compiled_binpat_vec_t &data,int flags); ea_t bin_search2(ea_t start_ea,ea_t end_ea,const uchar *image,const uchar *mask,size_t len,int flags); 使用示例如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <bytes.hpp> bool idaapi run(size_t) { compiled_binpat_vec_t binPat; parse_binpat_str(&binPat, 0x0, \"55 8B EC\", 16); ea_t SearchStartAddr = 0x401000; while (true) { SearchStartAddr= bin_search2(SearchStartAddr, 0x500000, binPat, 0x0); if (SearchStartAddr == BADADDR) { break; } msg(\"[SearchResult]:%a\\n\", SearchStartAddr); SearchStartAddr = SearchStartAddr + 3; } return true; }"
  },
  "IDASDK/(entry.hpp)导出函数相关.html": {
    "href": "IDASDK/(entry.hpp)导出函数相关.html",
    "title": "导出函数相关",
    "keywords": "导出函数相关 IDA内部维护着一组entry point数据，其中每个entry point: 有一个地址 有一个名称 可能包含一个序号 导出函数被视为entry point，同时程序的执行入口点和TLS回调函数入口也被视为entry point。 <entry.hpp>中提供了对entry point列表的一些操作。 示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <entry.hpp> bool idaapi run(size_t) { //获取entry point个数 size_t entryCount = get_entry_qty(); for (unsigned int idx = 0; idx < entryCount; ++idx) { //根据下标来获取序号 uval_t order = get_entry_ordinal(idx); ea_t FuncAddr = get_entry(order); qstring FuncName; get_entry_name(&FuncName, order); //根据序号与函数地址是否相等来判断是否为导出函数 if (order == FuncAddr) { msg(\"[NotExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } else { msg(\"[ExportFunc]:%s--%a\\n\", FuncName.c_str(), FuncAddr); } } return true; }"
  },
  "IDASDK/(enum.hpp)枚举类型.html": {
    "href": "IDASDK/(enum.hpp)枚举类型.html",
    "title": "枚举类型",
    "keywords": "枚举类型 enum.hpp包含了IDA中枚举信息相关的接口。 枚举类型或者位域(bit fields)表示为enum_t，实际上等价于tid_t，代表着一种数据类型的标识符。 IDA内部推测维护着一个枚举类型列表 对枚举类型进行遍历，示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <enum.hpp> struct MyVisitor:public enum_member_visitor_t { //函数返回非0值,代表终止遍历枚举类型 virtual int idaapi visit_enum_member(const_t cid, uval_t value) { qstring MemberName; get_enum_member_name(&MemberName, cid); msg(\"Member:%s----%d\\n\", MemberName.c_str(), value); return 0; } }; bool idaapi run(size_t) { //获取enum_t个数 size_t enumCount = get_enum_qty(); for (unsigned int idx = 0; idx < enumCount; ++idx) { enum_t enumId = getn_enum(idx); qstring enumName = get_enum_name(enumId); msg(\"%s\\n\", enumName.c_str()); MyVisitor EnumVisitor; for_all_enum_members(enumId, EnumVisitor); msg(\"----\\n\"); } return true; }"
  },
  "IDASDK/(funcs.hpp)函数相关.html": {
    "href": "IDASDK/(funcs.hpp)函数相关.html",
    "title": "函数相关",
    "keywords": "函数相关 首先要说明的就是，funcs.hpp所中围绕的主体func_t结构，指的是IDA主程序在汇编代码级别上提取的信息，这些信息是有限的，而IDA F5插件则是在这些信息基础之上更进一步的语义解析，二者有所不同。 遍历IDA中所有的函数，代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <funcs.hpp> bool idaapi run(size_t) { size_t funcCount= get_func_qty(); for (unsigned int idx = 0; idx < funcCount; ++idx) { func_t* pFunc = getn_func(idx); qstring FuncName; get_func_name(&FuncName, pFunc->start_ea); //库函数 if ((pFunc->flags & FUNC_LIB) != 0) { msg(\"LibFunc:%a--%s\\n\", pFunc->start_ea, FuncName.c_str()); continue; } msg(\"Func:%a--%s\\n\", pFunc->start_ea, FuncName.c_str()); } return true; } get_func_cmt / set_func_cmt 函数用于获取和设置函数的注释。 创建新的函数，可以使用如下函数，作用可以参考IDA在某处汇编代码处按下P键创建函数的功能。 bool add_func(ea_t ea1, ea_t ea2=BADADDR); 参数一ea1为函数的起始地址 参数二ea2为函数的结束地址，如果不填则表示自动探测函数范围。"
  },
  "IDASDK/(kernwin.hpp)内核与界面相关.html": {
    "href": "IDASDK/(kernwin.hpp)内核与界面相关.html",
    "title": "内核与界面相关",
    "keywords": "内核与界面相关 <kernwin.hpp>中定义了IDA的内核与界面之间的接口。 输出窗口相关的函数有: //清空输出窗口内容 void msg_clear(); //将输出窗口内容保存到文件中 bool msg_save(qstring &path); //打印格式化文本至输出窗口,类似于printf int msg(const char *format,...); 弹框提示信息相关的函数有: //弹出一个错误窗口，然后退出IDA void error(const char *format,...); //弹出一个警告窗口 void warning(const char *format,...); //弹出一个信息窗口 void info(const char *format,...); 弹出一个等待框，或者隐藏当前的等待框 void show_wait_box(const char *format, ...); void hide_wait_box(void); 需要注意的是，如果多次调用show_wait_box函数，那么IDA会将当前文本存储到堆栈中然后显示出新的文本，因此show_wait_box和hide_wait_box函数必须成对出现，否则弹出的等待框会使得IDA界面无法进行任何交互。 跳转函数如下，其余的可选参数基本没什么用。。。。 #define UIJMP_ACTIVATE 0x0001 #define UIJMP_DONTPUSH 0x0002 #define UIJMP_IDAVIEW 0x0004 bool jumpto(ea_t ea, int opnum=-1, int uijmp_flags=UIJMP_ACTIVATE) 获取当前屏幕光标处的地址，这个函数也算是一个交互函数吧，比如可以用来获取用户指向的代码/数据位置。 ea_t get_screen_ea(void); 创建一个选择窗口，可以使用choose函数，可以参考官方的choose.cpp示例，这里只介绍一些关键点 我们需要自定义一个结构体，然后继承chooser_t 重写类chooser_t的get_count函数，用来设置所显示列表的行数 重写类chooser_t的get_row函数，用来输出每一行内容 (可选)重写类chooser_t的enter函数，用来设置双击选项执行的动作 申请chooser结构体变量必须使用new来创建，关闭选择窗口内存会自动释放"
  },
  "IDASDK/(name.hpp)名称相关.html": {
    "href": "IDASDK/(name.hpp)名称相关.html",
    "title": "名称相关",
    "keywords": "名称相关 name.hpp中包含一些用于处理名称的函数。 设置或者删除指定地址处的项目名称。 bool set_name (ea_t ea, const char *name, int flags=0) 参数一为线性地址。 参数二为设置的新名称，如果为\"\",则表示删除名称。 返回真表示函数执行成功。 获取指定地址的名称 ssize_t get_ea_name (qstring *out, ea_t ea, int gtn_flags=0, getname_info_t *gtni=NULL) 参数一用于接收返回的名称。 参数二为指定的地址。 对名称进行解码，此函数一般用来解码C++的符号。 如不清楚什么是解码，可以参考 Name mangling - Wikipedia qstring demangle_name( const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL) int32 demangle_name( qstring *out, const char *name, uint32 disable_mask, demreq_type_t demreq=DQT_FULL); 第一个参数name是解码的文本 第二个参数disable_mask是解码的一些选项，和IDA主程序Options->Demangled names里面的选项差不多。 第三个参数demreq是想要得到的解码结果。"
  },
  "IDASDK/(pro.h)公共函数.html": {
    "href": "IDASDK/(pro.h)公共函数.html",
    "title": "公共函数",
    "keywords": "公共函数 <pro.h>是IDA工程中被包含的第一个头文件。 此接口定义了最通用的一些类型，函数和数据。 内存相关函数。 //malloc void * qalloc (size_t size); //realloc void * qrealloc (void *alloc, size_t newsize); //calloc void * qcalloc (size_t nitems, size_t itemsize); //free void qfree (void *alloc); 字符串相关函数，没啥介绍的，无非和C语言相比多做了一些安全检查。 char * qstrncpy (char *dst, const char *src, size_t dstsize); char * qstpncpy (char *dst, const char *src, size_t dstsize); char * qstrncat (char *dst, const char *src, size_t dstsize); char * qstrtok (char *s, const char *delim, char **save_ptr); int qsnprintf (char *buffer, size_t n, const char *format,...); int qsscanf (const char *input, const char *format,...); IDA还重新实现了STL模板库里面的一些类，例如 qstring、qvector、qlist、qstack，为了IDA的插件稳定性考虑，如果我们需要用到STL库，建议还是使用IDA提供的这些。不过IDA似乎没有提供map。。。。。，"
  },
  "IDASDK/(segment.hpp)区段相关.html": {
    "href": "IDASDK/(segment.hpp)区段相关.html",
    "title": "区段相关",
    "keywords": "区段相关 segment.hpp包含用来处理程序区段的一些函数。 遍历程序的区段 #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <segment.hpp> bool idaapi run(size_t) { int segCount = get_segm_qty(); for (int idx = 0; idx < segCount; ++idx) { segment_t* pSegment = getnseg(idx); qstring SectionName; get_segm_name(&SectionName, pSegment); msg(\"segment:%s from %a to %a\\n\", SectionName.c_str(), pSegment->start_ea, pSegment->end_ea); } return true; }"
  },
  "IDASDK/(struct.hpp)结构体类型.html": {
    "href": "IDASDK/(struct.hpp)结构体类型.html",
    "title": "结构体类型",
    "keywords": "结构体类型 IDA内部维护着一个结构体列表，IDA中的Structures窗口可以看到结构体列表的信息。 创建结构体 tid_t add_struc(uval_t idx, const char *name, bool is_union=false); 第一个参数，idx为结构体的索引，代表所插入的结构体在IDA存储的列表中的顺序，如果idx为-1，表示添加结构体到列表末尾。 第二个参数，name为结构体的名称，不能为不合法名称，也不可以与数据库已有的名称重复。 返回值tid_t实际上就是个整数，用于标识唯一的结构体类型。如果返回-1，代表创建结构体失败。 通过结构体的名称来索引到对应的结构体标识符: tid_t get_struc_id(const char *name); 根据结构体标识符来索引到对应的结构体名称: qstring get_struc_name(tid_t id); 设置结构体的注释和获取结构体的注释可参考如下函数 bool set_struc_cmt(tid_t id, const char *cmt, bool repeatable); ssize_t get_struc_cmt(qstring *buf, tid_t id, bool repeatable); 通过标识符tid_t索引得到对应的结构体类型信息struc_t: struc_t* get_struc(tid_t id); 获取一个结构体的大小 asize_t get_struc_size (const struc_t *sptr); asize_t get_struc_size (tid_t id); 给结构体添加成员 struc_error_t add_struc_member( struc_t *sptr, const char *fieldname, ea_t offset, flags_t flag, const opinfo_t *mt, asize_t nbytes); 第一个参数sptr为要添加成员的结构体 第二个参数fieldname为要添加的成员名称 第三个参数offset为要添加的成员在结构体中的偏移 第四个参数flag为结构体的类型标记，可在bytes.hpp中找到如下定义 flags_t idaapi byte_flag(void) { return FF_DATA|FF_BYTE; } ///< Get a flags_t representing a byte flags_t idaapi word_flag(void) { return FF_DATA|FF_WORD; } ///< Get a flags_t representing a word flags_t idaapi dword_flag(void) { return FF_DATA|FF_DWORD; } ///< Get a flags_t representing a double word flags_t idaapi qword_flag(void) { return FF_DATA|FF_QWORD; } ///< Get a flags_t representing a quad word flags_t idaapi oword_flag(void) { return FF_DATA|FF_OWORD; } ///< Get a flags_t representing a octaword flags_t idaapi yword_flag(void) { return FF_DATA|FF_YWORD; } ///< Get a flags_t representing a ymm word flags_t idaapi zword_flag(void) { return FF_DATA|FF_ZWORD; } ///< Get a flags_t representing a zmm word flags_t idaapi tbyte_flag(void) { return FF_DATA|FF_TBYTE; } ///< Get a flags_t representing a tbyte flags_t idaapi strlit_flag(void) { return FF_DATA|FF_STRLIT; } ///< Get a flags_t representing a string literal flags_t idaapi stru_flag(void) { return FF_DATA|FF_STRUCT; } ///< Get a flags_t representing a struct flags_t idaapi cust_flag(void) { return FF_DATA|FF_CUSTOM; } ///< Get a flags_t representing custom type data flags_t idaapi align_flag(void) { return FF_DATA|FF_ALIGN; } ///< Get a flags_t representing an alignment directive flags_t idaapi float_flag(void) { return FF_DATA|FF_FLOAT; } ///< Get a flags_t representing a float flags_t idaapi double_flag(void) { return FF_DATA|FF_DOUBLE; } ///< Get a flags_t representing a double flags_t idaapi packreal_flag(void) { return FF_DATA|FF_PACKREAL; } ///< Get a flags_t representing a packed decimal real 第五个参数mt为要添加的成员类型的额外信息，只有当成员类型为结构体、偏移、枚举、字符串、结构体偏移以上一种时有效。 第六个参数nbytes为要添加的成员的大小，大小必须和flag对应，例如当参数flag填 dword_flag() 时，nbytes应该填4。 当填0的时候，该成员会表示成一个 变量结构体 （即大小不确定）。 设置结构体某个成员的名称 bool set_member_name(struc_t *sptr, ea_t offset,const char *name); 参数一sptr为要目标成员的结构体 参数二offset为目标成员所处在结构体的偏移大小 参数三name为目标成员要设置的名称 设置变量的类型，该函数可用于设置成员为一些基础类型(byte,word,dword...)，参数和add_struc_member差不多，故省略介绍。 bool set_member_type(struc_t *sptr, ea_t offset, flags_t flag,const opinfo_t *mt, asize_t nbytes); 如果要将结构体成员设置为类型库中的其它类型，可使用以下函数 smt_code_t set_member_tinfo( struc_t *sptr, member_t *mptr, uval_t memoff, const tinfo_t &tif, int flags); 参数一sptr为成员所在的结构体 参数二mptr为目标成员 参数三memoff成员内部的偏移 参数四tif为要设置的成员类型 参数五flags为设置的一些参数，有如下选择 #define SET_MEMTI_MAY_DESTROY 0x0001 ///< may destroy other members #define SET_MEMTI_COMPATIBLE 0x0002 ///< new type must be compatible with the old #define SET_MEMTI_FUNCARG 0x0004 ///< mptr is function argument (can not create arrays) #define SET_MEMTI_BYTIL 0x0008 ///< new type was created by the type subsystem #define SET_MEMTI_USERTI 0x0010 ///< user-specified type 例如我们想要创建一个结构体，结构体第一个成员是自身的指针，代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> #include <struct.hpp> #include <typeinf.hpp> til_t* idati; bool idaapi run(size_t) { idati = (til_t*)get_idati(); tid_t idStruct = add_struc(-1, \"TestStruct\"); struc_t* pStruct = get_struc(idStruct); add_struc_member(pStruct, \"member_0\", 0, dword_flag(), NULL, 0x4); tinfo_t type; type.create_typedef(idati, \"TestStruct\"); type.create_ptr(type); set_member_tinfo(pStruct, get_member(pStruct, 0), 0, type, SET_MEMTI_MAY_DESTROY); return true; } 如果要遍历一个结构体的成员，可以参考如下代码: bool idaapi run(size_t) { //要遍历的某个结构体的名称 struc_t* pStruct = get_struc(get_struc_id(\"GUID\")); if (!pStruct) { return true; } for (unsigned int n = 0; n < pStruct->memqty; ++n) { member_t pMember = pStruct->members[n]; qstring qMemberName = get_member_name(pMember.id); msg(\"[Member]:%s\\n\", qMemberName.c_str()); } return true; } 扩充或者收缩一个结构体 bool expand_struc(struc_t *sptr, ea_t offset, adiff_t delta, bool recalc=true); 参数: sptr表示需要执行操作的结构体。 offset表示结构体的偏移。 delta表示要扩充的字节大小，如果为负数则表示要移除的字节大小。 recalc表示是否重新计算结构体类型被使用的地方。 返回值: 返回true表示函数执行成功。 需要注意的是，一个空的结构体是无法执行expand_struc函数的，可以参考以下代码初始化一个结构体 //name为结构体的名称,size为结构体的大小 tid_t CreateStructure(const char* name, int size) { //已存在相同名称的结构体 tid_t structId = get_struc_id(name); if (structId != BADADDR) { return structId; } structId = add_struc(-1, name); if (structId == BADADDR) { return structId; } struc_t* pStruct = get_struc(structId); char fieldName[64] = { 0 }; for (int n = 0; n < size; ++n) { qsnprintf(fieldName, sizeof(fieldName), \"field_%a\", n); add_struc_member(pStruct, fieldName, n, 0, NULL, 1); } return structId; }"
  },
  "IDASDK/(typeinf.hpp)声明类型.html": {
    "href": "IDASDK/(typeinf.hpp)声明类型.html",
    "title": "声明类型",
    "keywords": "声明类型 IDA内部记录着一个声明类型库，通过IDA的Local Types窗口我们可以看到里面的声明类型。 获取IDA内部的声明类型库。 til_t * get_idati(void); 解析多条声明，并将它们存储至声明类型库。 int parse_decls( til_t *til, const char *input, printer_t *printer, int hti_flags); 第一个参数为要存储解析声明结果的声明类型库。 第二个参数代表声明的文本，如果参数四 hti_flags 为HTI_FIL，则代表包含声明的文件路径。 第三个参数为一个回调函数指针，用于输出解析过程的一些信息。 第四个参数用来设置如何解析声明的一些标志。 这个函数使用频率还是很高的，使用例子如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <typeinf.hpp> til_t* idati = NULL; bool idaapi run(size_t) { const char Decls[] = \"\\ struct __declspec(align(4)) Tree_nod\\ {\\ Tree_nod* _Left;\\ Tree_nod* _Parent;\\ Tree_nod* _Right;\\ char _Color;\\ char _Isnil;\\ int _Myval; \\ };\\ struct map\\ {\\ Tree_nod* _MyHead;\\ unsigned int _Mysize;\\ };\"; idati = (til_t*)get_idati(); parse_decls(idati, Decls, NULL,0); return true; } 调用函数后，类型声明就存储到了IDA的声明类型库中。 导入声明类型至IDB中。相当于将Local Types窗口中的声明拷贝至Structures窗口。 tid_t import_type (const til_t *til, int idx, const char *name, int flags=0) 参数一为要导入声明的声明类型库。 参数二为新类型在列表中的位置，一般填-1就行了，表示加入到列表末尾。 参数三为要导入声明的名称。 参数四可不填。 返回值为拷贝得到的结构体的类型ID。 修改指定地址的声明。 该函数首先会解析声明文本，然后调用apply_tinfo函数进行修改。 bool apply_cdecl(til_t *til, ea_t ea, const char *decl, int flags=0); 参数一为声明类型库。 参数二为指定的线性地址。 参数三为声明文本。 参数四为附加参数: TINFO_GUESSED告诉IDA这是一个模糊的声明。 TINFO_DEFINITE告诉IDA这是一个精确的声明。这会影响到IDA的一些解析。 TINFO_DELAYFUNC，如果声明的种类为函数声明，但是指定的线性地址不存在函数，则尝试建立函数。 TINFO_STRICT，在修改声明之前绝不对类型进行转换。 apply_cdecl 常常被用来修改函数声明，示例如下: til_t* idati = NULL; bool idaapi run(size_t) { idati = (til_t*)get_idati(); apply_cdecl(idati, 0x401000, \"int __cdecl sub_401000(int a, int b, int *c);\", TINFO_DEFINITE); //注意声明末尾有一个;号 return true; }"
  },
  "IDASDK/(ua.hpp)反汇编引擎.html": {
    "href": "IDASDK/(ua.hpp)反汇编引擎.html",
    "title": "反汇编引擎",
    "keywords": "反汇编引擎 包含用来处理程序指令的反汇编相关函数。 一条指令的反汇编由以下三步组成: 指令分析:ana.cpp 模拟分析:emu.cpp 转换为反汇编文本:out.cpp 判断指定地址的字节是否可以被解码为一条有效指令 bool can_decode (ea_t ea) 参数一ea表示指定的线性地址。 函数返回true表示可以被解码为有效指令。 对一条指令进行反汇编，使用以下函数 int decode_insn (insn_t *out, ea_t ea) 参数一out为返回的指令信息结果 参数二ea为要进行反汇编的指令地址。 返回值为指令的长度，如果为0则表示反汇编失败。 IDA还提供了一个强大的逆反汇编功能，可以用以下函数对指定地址的上一条指令进行反汇编 ea_t decode_prev_insn (insn_t *out, ea_t ea) 参数一out为返回的指令信息结果 参数二ea表示要从哪个地址开始反汇编上一条指令 返回值为上一条指令的地址，如果返回 BADADDR 表示反汇编失败。 insn_t 代表着指令的反汇编结果，该结构体部分成员如下 class insn_t { ... ea_t ea; //该指令的线性地址 uint16 itype; //内部指令类型,由IDP来定义 uint16 size; //指令长度 ... op_t ops[UA_MAXOP]; //操作数数组 } 我们得到insn_t后，一般先通过判断itype来确定指令的类型，这个itype是个枚举类型，不同的处理器对应的枚举类型都不同，需要自行去allins.hpp中寻找。 得到指令的类型后我们就可以通过解析ops数组来进一步得到详细的信息了。 ops数组大小固定为8，但大部分指令的有效op并没有这么多。 现假设在X86平台下，我们需要打印出某个函数里面call Register、call [MemAddr]这两种形式的全部指令。 示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <ua.hpp> #include <allins.hpp> qstring RegToName(uint16 reg) { qstring ret; switch (reg) { case 0x0: ret = \"eax\"; break; case 0x1: ret = \"ecx\"; break; case 0x2: ret = \"edx\"; break; case 0x3: ret = \"ebx\"; break; case 0x4: ret = \"esp\"; break; case 0x5: ret = \"ebp\"; break; case 0x6: ret = \"esi\"; break; case 0x7: ret = \"edi\"; break; default: break; } return ret; } bool idaapi run(size_t) { //假设函数之间的指令是连续的 //某个函数的起始地址 ea_t FuncStart = 0x00401180; int iLen = 0; do { insn_t ins; iLen = decode_insn(&ins, FuncStart); if (ins.itype == NN_callni) { //call eax这类的指令 if (ins.ops[0].type == o_reg) { qstring Reg = RegToName(ins.ops[0].reg); msg(\"[Instruction]:%a---call %s\\n\", FuncStart, Reg.c_str()); FuncStart += iLen; continue; } //call [MemAddr] if (ins.ops[0].type == o_mem) { msg(\"[Instruction]:%a---call [%a]\\n\", FuncStart, ins.ops[0].addr); FuncStart += iLen; continue; } } FuncStart += iLen; } while (iLen); return true; }"
  },
  "IDASDK/(xref.hpp)交叉引用.html": {
    "href": "IDASDK/(xref.hpp)交叉引用.html",
    "title": "交叉引用",
    "keywords": "交叉引用 xref.hpp包括和交叉引用相关的一些函数。 交叉引用分为两种:代码交叉引用和数据交叉引用。 交叉引用会自动进行排序。 获取某个全局变量所有的交叉引用地址，示例代码如下: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <xref.hpp> bool idaapi run(size_t) { //可以自行输入一个全局变量的地址... ea_t GlobalVarAddr = 0x489085; //打印所有的代码交叉引用 ea_t XrefAddr = get_first_cref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"CodeXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_cref_to(GlobalVarAddr, XrefAddr); } //打印所有的数据交叉引用 XrefAddr = get_first_dref_to(GlobalVarAddr); while (XrefAddr != BADADDR) { msg(\"DataXrefAddr:%a\\n\", XrefAddr); XrefAddr = get_next_dref_to(GlobalVarAddr, XrefAddr); } return true; }"
  },
  "IDASDK/Windows下开发环境配置.html": {
    "href": "IDASDK/Windows下开发环境配置.html",
    "title": "Windows下开发环境配置:",
    "keywords": "Windows下开发环境配置: 1.建立一个空的Visual Studio项目，添加IDADemo.cpp文件 2.由于7.0版本以后的IDA插件必须都是64位的，因此编译平台选择x64 3.进行如下设置 配置属性->常规:更改\"配置类型\"为 动态库(.dll) C/C++ -> 常规:添加SDK的include路径到\"附加包含目录\"一栏，比如D:\\idasdk74\\include C/C++ -> 预处理器:添加 __NT__ C/C++ -> 代码生成:更改\"安全检查\"为 禁用安全检查(/GS-) 链接器 -> 常规:添加SDK的lib库路径到\"附加库目录\"一栏，比如针对ida.exe所写的插件添加D:\\idasdk74\\lib\\x64_win_vc_32，针对ida64.exe所写的插件添加D:\\idasdk74\\lib\\x64_win_vc_64。 链接器 -> 附加依赖项: 添加 ida.lib 到\"附加依赖项\"一栏。 这样一个IDA插件开发环境就搭建好了。 插件模板介绍: 在IDADemo.cpp添加如下模板代码: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <kernwin.hpp> //以上是导入的SDK头文件 int idaapi init(void) { //IDA在启动的时候会调用每个插件的init函数。 //返回值有三种选项: //PLUGIN_SKIP适合那些不支持的插件，IDA将不会加载该插件 //PLUGIN_OK适合那些执行一次性功能的插件 //PLUGIN_KEEP适合那些需要一直保持功能的插件 return PLUGIN_OK; } void idaapi term(void) { //当结束插件时，一般您可以在此添加一点任务清理的代码。 return; } bool idaapi run(size_t) { //当按下热键时候,执行功能的入口函数 warning(\"Hello, world!\"); return true; } static char comment[] = \"It's a plugin to show Hello world!\"; plugin_t PLUGIN = { IDP_INTERFACE_VERSION, 0, // 插件的一些属性,一般为0即可 init, // initialize term, // terminate. this pointer may be NULL. run, // invoke plugin comment, // 插件的说明,会显示在IDA下方的状态栏中 \"\", // multiline help about the plugin \"Hello, world\", // 插件在列表中显示的名称 \"Alt-F1\" // 插件想要注册的功能快捷键 }; 编译运行该插件后，会显示出提示框Hello,world! 当IDA加载文件后，会生成一个idainfo信息，该信息存在在数据库文件中(即IDB文件)。 idainfo结构体定义在<ida.hpp>文件中，下面列出一部分值 struct idainfo { char tag[3]; //固定为'IDA' char zero; //没用 ushort version; //数据库版本 char procname[16]; //当前处理器名称 ... ushort filetype; // 被反汇编的文件类型,例如f_PE,f_ELF,参考filetype_t ea_t startIP; // 程序开始运行时,[E]IP寄存器的值 ea_t startSP; // 程序开始运行时,[E]SP寄存器的值 ea_t main; // IDA解析出的主函数入口点的线性地址 ea_t minEA; // 程序的最小线性地址 ea_t maxEA; // 程序的最大线性地址 ... }; 该结构体以全局变量inf的形式定义在<ida.hpp>头文件中，我们可以直接使用。 比方说，我们想要编写的插件，只想处理Intel x86处理器类型下的PE和ELF两种格式的文件，编写以下代码: #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> int idaapi init(void) { qstring ProcName = inf.procname; if (ProcName != \"metapc\" || (inf.filetype != f_ELF && inf.filetype != f_PE)) { return PLUGIN_SKIP; } return PLUGIN_OK; } 这样遇到不符合的文件，插件将不会载入。"
  },
  "IDASDK/导入函数.html": {
    "href": "IDASDK/导入函数.html",
    "title": "导入函数",
    "keywords": "导入函数 在nalt.hpp中包含一些与导入函数相关的函数。 遍历导入函数 #include <ida.hpp> #include <idp.hpp> #include <loader.hpp> #include <name.hpp> int enumIMPORTS(ea_t ea, const char* name, uval_t ord, void* param) { qstring FuncName; //有时候导入表中只有序号,没有导入函数名称 //这个时候可以尝试去获取IDA解析的结果 if (!name) { get_ea_name(&FuncName, ea); } else { FuncName = name; } msg(\"[order--addr--name]:%d--%a--%s\\n\", ord, ea, FuncName.c_str()); //函数返回<=0的值,则终止遍历 return 1; } bool idaapi run(size_t) { uint num = get_import_module_qty(); for (unsigned int n = 0; n < num; ++n) { qstring Module_Name; if (!get_import_module_name(&Module_Name, n))//获取模块名称失败 { continue; } msg(\"[Module]:%s\\n\", Module_Name.c_str()); enum_import_names(n, enumIMPORTS); } return true; }"
  },
  "IDASDK/文件读写.html": {
    "href": "IDASDK/文件读写.html",
    "title": "文件读写",
    "keywords": "文件读写 官方是不建议我们在插件中使用C语言的文件读写接口的。 读写文件相关接口定义在<diskio.hpp>和<fpro.h>中 idadir 函数用于获取IDA自身相关目录 const char *ida_export idadir(const char *subdir); subdir其实只有固定的选择，有以下几种 #define CFG_SUBDIR \"cfg\" #define IDC_SUBDIR \"idc\" #define IDS_SUBDIR \"ids\" #define IDP_SUBDIR \"procs\" #define LDR_SUBDIR \"loaders\" #define SIG_SUBDIR \"sig\" #define TIL_SUBDIR \"til\" #define PLG_SUBDIR \"plugins\" 官方提供了一组几乎和C语言完全一样的接口，供我们读写文件 FILE *qfopen(const char *file, const char *mode); ssize_t qfread(FILE *fp, void *buf, size_t n); ssize_t qfwrite(FILE *fp, const void *buf, size_t n); qoff64_t qftell(FILE *fp); int qfseek(FILE *fp, qoff64_t offset, int whence); int qfclose(FILE *fp); int qflush(FILE *fp); ...... 这里也就不做过多介绍了。 此外，IDA还封装了一些额外的API供我们使用，毕竟光上面那些根本不够用 ssize_t qgetline (qstring *buf, FILE *fp) 此函数一般用来逐行读取文本。"
  },
  "index.html": {
    "href": "index.html",
    "title": "IDA插件开发",
    "keywords": "IDA插件开发 IDA插件根据版本来划分，大致可分为6.x和7.x两种版本。 IDA 7.x相较于6.x，有以下几点改动: SDK中的函数有较大变化，函数增加、函数减少、函数名称变化。 原先6.x版本idaq.exe使用32位编译的插件模块，idaq64.exe使用64位编译的插件模块。 现在7.x版本ida.exe和ida64.exe都经64位编译，使用的IDA插件模块也都必须使用64位进行编译。 插件的后缀名之前32位和64位插件分别是 .plw 和 .p64 ，现在分别是 .dll 和 64.dll 。 IDA提供的应用SDK分为IDA SDK和HexRays SDK两种"
  },
  "README.html": {
    "href": "README.html",
    "title": "IDADoc",
    "keywords": "IDADoc 用于存放IDA相关的资料和文档 https://fjqisba.github.io/IDADoc/"
  }
}